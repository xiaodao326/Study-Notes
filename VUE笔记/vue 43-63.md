# 01_普通组件的注册使用
- 局部注册：只能在注册的组件内使用
    - 创建.vue文件（三个组成部分)
    - 在使用的组件内导入并注册
- 全局注册：所有组件内都能使用
    - 创建.vue文件（三个组成部分)
    - main.js 中进行全局注册
- 使用：
    当成html标签使用<组件名></组件名>
- 注意：
    组件名规范→大驼峰命名法，如：HmHeader
## 总结
1. 两种注册方式：
- 局部注册:
    1. 创建.vue组件（单文件组件)
    2. 使用的组件内导入，并局部注册
- 全局注册：
    1. 创建.vue组件（单文件组件)
    2. main.js内导入，并全局注册 Vue.component(组件名，组件对象)
2. 使用：
    <组件名></组件名>
3. 技巧:
    一般都用局部注册，如果发现确实是通用组件，再抽离到全局。
# 02_组件的样式冲突 scoped
- 默认情况：写在组件中的样式会 全局生效→因此很容易造成多个组件之间的样式冲突问题。
    1. 全局样式：默认组件中的样式会作用到全局
    2. 局部样式：可以给组件加上scoped属性，可以让样式只作用于当前组件
- scoped原理?
    1. 当前组件内标签都被添加data-v-hash值 的属性
    2. 2.CSs选择器都被添加`[data-v-hash值]`的属性选择器
- 最终效果：
    必须是当前组件的元素，才会有这个自定义属性，才会被这个样式作用到
# 03_data是一个函数
- 一个组件的data选项必须是一个函数。→ 保证每个组件实例，维护独立的一份数据对象。
- 每次创建新的组件实例，都会新执行一次data函数，得到一个新对象。
# 04_组件通信
- 什么是组件通信？
    组件通信，就是指组件与组件 之间的数据传递。
    - 组件的数据是独立的，无法直接访问其他组件的数据。
    - 想用其他组件的数据→组件通信
## 父子通信流程图：
1. 父组件通过props将数据传递给子组件
2. 子组件利用$emit通知父组件修改更新
    -  父→子
        父组件通过 props将数据传递给子组件
    - 子→父
        子组件利用$emit通知父组件，进行修改更新
### 总结
1. 两种组件关系分类 和对应的组件通信方案
    - 父子关系
        props & $emit
    - 非父子关系
        provide &inject 或 eventbus
    - 通用方案
        vuex
2. 父子通信方案的核心流程
    - 父传子props:
        1. 父中给子添加属性传值
        2. 子props接收
        3. 使用
    - 子传父$emit:
        1. 子$emit 发送消息
        2. 父中给子添加消息监听
        3. 父中实现处理函数
# 04_prop
## 什么是prop
- Prop定义：
    组件上注册的一些 自定义属性
- Prop作用：
    向子组件传递数据
- 特点：
    - 可以 传递 任意数量的prop
    - 可以传递 任意类型的prop
## props 校验
- 思考：
    组件的prop可以乱传么?
- 作用：
    为组件的prop指定验证要求，不符合要求，控制台就会有错误提示→帮助开发者，快速发现错误
- 语法：
```
props:}{
校验的属性名：类型 // Number String Boolean...
```
- 类型检测
- 非空校验
- 默认值
- 自定义校验
## prop&data、单向数据流
- 共同点：
    都可以给组件提供数据。
- 区别:
    - data的数据是自己的→随便改
    - prop的数据是外部的→不能直接改，要遵循单向数据流
- 单向数据流：父级prop的数据更新，会向下流动，影响子组件。这个数据流动是单向的。
# 05_v-model
- 原理：
    v-model本质上是一个语法糖。例如应用在输入框上，就是value属性和input事件的合写。
- 作用：
    提供数据的双向绑定
    1. 数据变，视图跟着变：value
    2. 视图变，数据跟着变@input
- 注意：
    $event用于在模板中，获取事件的形参
## 表单类组件封装&v-model简化代码
1. 表单类组件 封装
    - 父传子：数据 应该是父组件props传递过来的，v-model拆解 绑定数据
    - 子传父：监听输入，子传父传值给父组件修改
2. 父组件v-model简化代码，实现子组件 和父组件数据 双向绑定
    - 子组件中：props通过value接收，事件触发input
    - 父组件中：v-model给组件直接绑数据（：value+@input）
## 总结
1. 表单类基础组件封装思路
    - 父传子：父组件动态传递prop数据，拆解v-model，绑定数据
    - 子传父：监听输入，子传父传值给父组件修改
    - 本质：实现了实现 子组件和 父组件数据的双向绑定
2. v-model简化代码的核心步骤
    - 子组件中：props通过value接收，事件触发input
    - 父组件中：v-model 给组件直接绑数据
# 06_.sync 修饰符
- 作用：
    可以实现 子组件与父组件数据的双向绑定，简化代码
- 特点：
    prop属性名，可以自定义，非固定为value
- 场景：
    封装弹框类的基础组件，visible属性true显示false隐藏
- 本质：
    就是 :属性名 和@update：属性名合写
# 07_ref 和$refs
- 作用：
    利用ref和$refs可以用于 获取dom元素，或组件实例
- 特点：
    查找范围→当前组件内（更精确稳定）
- 获取dom:
    1. 目标标签-添加ref属性
    2. 恰当时机，通过this.$refs.xxx，获取目标标签
- 获取组件：
    1. 目标组件-添加ref属性
    2. 恰当时机，通过this.$refs.xxx，获取目标组件，就可以调用组件对象里面的方法
# 08_Vue异步更新、$nextTick
- Vue是异步更新DOM（提升性能)
- $nextTick：
    等DOM更新后，才会触发执行此方法里的函数体
- 语法：
    this.$nextTick(函数体）
## 总结
1. Vue是异步更新DOM的
2. 想要在 DOM 更新完成之后做某件事，可以使用 $nextTick
```
this.$nextTick(()=>{
    //业务逻辑
})
```
# 09_自定义指令
- 自定义指令：自己定义的指令，可以封装一些dom操作，扩展额外功能
- 全局注册-语法
```
Vue.directive('指令名'，{
  "inserted" (el) {
    //可以对el标签，扩展额外功能
    el.focus()
  }
})
```
- 局部注册-语法
```
directives:{
  "指令名"：{
    inserted (){
      // 可以对 el 标签，扩展额外功能
      el.focus()
    }
  }
}
```
# 10_自定义指令-指令的值
- 需求：
    实现一个color 指令-传入不同的颜色，给标签设置文字颜色
- 语法：在绑定指令时，可以通过“等号”的形式为指令绑定具体的参数值
    `<div v-color="color">我是内容</div>`
- 通过binding.value可以拿到指令值，指令值修改会触发update函数。
```
directives: {
  color:{
    inserted (el, binding) {
      el.style.color = binding. value 
    },
    update (el, binding) {
      el.style.color = binding.value
    }
  }
}
```
## 总结
1. 通过指令的值相关语法，可以应对更复杂指令封装场景
2. 指令值的语法：
    1. v-指令名="指令值”，通过等号可以绑定指令的值
    2. 通过binding.value 可以拿到指令的值
    3. 通过update钩子，可以监听指令值的变化，进行dom更新操作
        inserted 钩子中，binding.value判断指令的值，设置默认状态
        update 钩子中，binding.value判断指令的值，更新类名状态