# 01_指令修饰符
- 通过==“.”==指明一些指令 ==后缀==，不同 ==后缀== 封装了不同的处理操作→简化代码
1. 按键修饰符
    ==`@keyup.enter`==→键盘回车监听
2. v-model修饰符
    - ==`v-model.trim`==→去除首尾空格
    - ==`v-model.number`==→转数字
3. 事件修饰符
    `@事件名.stop`→ 阻止冒泡
    `@事件名.prevent` →阻止默认行为
# 02_v-bind 对于样式控制的增强-操作class
- 语法 ：
    `:class="对象/数组"`
1. 对象→键就是类名，值是布尔值。如果值为true，有这个类，否则没有这个类
    适用场景：一个类名，来回切换
    `<div class="box" :class="{ 类名1：布尔值，类名2：布尔值 }"></div>`
2. 数组→数组中所有的类，都会添加到盒子上，本质就是一个class列表
    适用场景：批量添加或删除类
    `<div class="box" :class="[ 类名1，类名2，类名3 ]"></div>`
        `class="['pink','big']"`
# 03_v-model 应用于其他表单元素
- 常见的表单元素都可以用v-model绑定关联→快速 获取或设置 表单元素的值
- 它会根据 控件类型 自动选取 正确的方法 来更新元素
 - 输入框 input:text
    value
 - 文本域 textarea
    value
 - 复选框 input:checkbox
    checked
 - 单选框 input:radio
    checked
 - 下拉菜单 select
    value
# 04_计算属性
- 概念：
    基于==现有的数据==，计算出来的==新属性==。==依赖==的数据变化，自动重新计算。
- 语法：
    1. 声明在==computed配置项==中，一个计算属性对应一个函数
    2. 使用起来和普通属性一样使用{{==计算属性名==}}
# 05_computed 计算属性vs methods方法
## computed 计算属性：
- 作用：
    封装了一段对于==数据==的处理，求得一个==结果==。
- 语法：
    1. 写在==computed==配置项中
    2. 作为属性，直接使用→ ==this.计算属性== {{==计算属性==}}
- ==缓存特性（提升性能）==:
    计算属性会对计算出来的==结果缓存==，再次使用直接读取缓存，依赖项变化了，会==自动==重新计算→并==再次缓存==
## methods方法：
- 作用：
    给实例提供一个==方法==，调用以处理==业务逻辑==。
- 语法：
    1. 写在 ==methods== 配置项中
    2. 作为方法，需要调用 → ==this.方法名（）=={{ ==方法名()==}} @事件名="==方法名=="
# 06_计算属性完整写法
- 计算属性默认的简写，只能读取访问，==不能“修改"==。
- 如果要==“修改”==→需要写计算属性的==完整写法==。
- 简写：
```
computed:{
  计算属性名（）{
    一段代码逻辑（计算逻辑）
    return 结果
  }
}
```
- 完整写法：
```
computed:{
  计算属性名：{
    get(){
      一段代码逻辑(计算逻辑)
      return 结果
    },
    set(修改的值）{
      一段代码逻辑（修改逻辑）
    }
  }
}
```
# 07_watch 侦听器（监视器）
- 作用：
    ==监视数据变化==，执行一些 业务逻辑或异步操作。
- 语法：
    1. ==简单写法→简单类型数据，直接监视==
        监视简单类型的变化
    2. 完整写法→添加额外==配置项==
        1. 添加额外的配置项（深度监视复杂类型，立刻执行)
        2. deep:true 对复杂类型深度监视
        3. immediate: true初始化立刻执行一次handler方法
- 简单写法：
```
data: {‘苹果’,
  words:
  obj:{
    words：‘苹果'
  }
},

watch:{
  // 该方法会在数据变化时，触发执行
  数据属性名（newValue，oldValue){
    一些业务逻辑 或 异步操作。
  },
  ‘对象.属性名’（newValue，oldValue){
    一些业务逻辑 或异步操作。
  }
}
```
- 完整写法：
```
data:{
  obj:{
    words：‘苹果’,
    lang:'italy'
  }，
}，

watch:{// watch 完整写法
  数据属性名：{
    deep:true，// 深度监视
    handler(newValue) {
      console.log(newValue)
    }
  }
}
```
# 08_Vue生命周期 和 生命周期的四个阶段
- Vue生命周期：一个Vue实例从 ==创建== 到 ==销毁== 的整个过程。
- 生命周期四个阶段：①创建②挂载③更新④销毁
- 时间线：
    new Vue () 创建 → ①创建阶段 响应式数据...→==发送初始化 渲染请求== → ②挂载阶段 渲染模板→==操作dom== → ③更新阶段 数据修改，更新视图 → ④销毁阶段 销毁实例
## Vue生命周期函数（钩子函数）
- Vue生命周期过程中，会自动运行一些函数，被称为==【生命周期钩子】==→让开发者可以在==【特定阶段】==运行==自己的代码==。
- 时间线：
    new Vue () 创建 →before Create → ①创建阶段 → ==created== →before Mount → ②挂载阶段 → ==mounted== → before Update → ③更新阶段 → updated → ==before Destroy== → ④销毁阶段 → destroyed
## 总结
- 四个阶段，八个钩子 → 三个常用 created, mounted, before Destroy
# 09_组件化开发&根组件
- 组件化：
    一个页面可以拆分成==一个个组件==，每个组件有着自己独立的==结构、样式、行为==。
    - 好处：
        便于==维护==，利于==复用==→提升==开发效率==。
        组件分类：普通组件、根组件。
- 根组件：
    整个应用最上层的组件，包裹所有普通小组件。
## App.vue文件（单文件组件）的三个组成部分
- 三部分组成：
    template：结构（有且只能一个根元素）
    script：js逻辑
    style：样式（可支持less，需要装包)
## 总结
- 组件化：
    页面可拆分成一个个组件，每个组件有着独立的结构、样式、行为
    - 好处：便于维护，利于复用→提升开发效率。
    - 组件分类：普通组件、根组件。
- 根组件：
    - 整个应用最上层的组件，包裹所有普通小组件。
    - 一个根组件App.vue，包含的三个部分:
        - template 结构（只能有一个根节点)
        - style 样式（可以支持less，需要装包 less和 less-loader)
        - script行为