# 01_do-while循环
```
初始化语句;
do {
  循环体语句;
  迭代语句；
}while（循环条件);
```
```
int i=0;
do {
  System.out.println("Hello world! ");
  i++;
} while( i<3);
```
- do-while循环的特点：
    先执行后判断。
## 三种循环的区别小结
- for循环 和while循环（先判断后执行）；do...while （先执行后判断）
- for循环和while循环的执行流程是一模一样的，功能上无区别，for能做的while也能做，反之亦然。
- 使用规范：如果已知循环次数建议使用for循环，如果不清楚要循环多少次建议使用while循环。
- 其他区别：for循环中，控制循环的变量只在循环中使用。while循环中，控制循环的变量在循环后还可以继续使用。
## 死循环
- 可以一直执行下去的一种循环，如果没有干预不会停下来。
## 循环嵌套
- 循环中又包含循环
- 循环嵌套的特点
    外部循环每循环一次，内部循环会全部执行完一轮。
## 跳转关键字
- break：跳出并结束当前所在循环的执行。
- continue：用于跳出当前循环的当次执行，直接进入循环的下一次执行。
- 注意事项
    - break：只能用于结束所在循环，或者结束所在switch分支的执行。
    - continue ：只能在循环中进行使用。
# 01_Random
- 作用：生成随机数。
- 注意：
    nextInt(n）功能只能生成：e至 n-1之间的随机数，不包含n。
## 总结
1. Random生成随机数需要几步？
    1. 导包：import java.util.Random;
    2. Random r= new Random();
    3. int number = r.nextlnt(10);
2. 如何生成65-91之间的随机数？
    - 65-91 => -65=> (0-26)+65
    - int number = r.nextlnt(27)+65;
# 03_数组
- 数组是什么
    数组就是一个容器，用来存储一批同种类型的数据。
- 有变量，为什么还用数组？
    结论：遇到批量数据的存储和操作时，数组比变量更适合。
## 静态初始化数组
### 定义
- 定义数组的时候直接给数组赋值。
- 静态初始化数组的格式：
```
//完整格式
数据类型[] 数组名=new 数据类型[](元素1，元素2，元素3..3;
intll ages = new int[]{12,24, 36}
doublel] scores = new double[]{89.9,99.5, 59.5,88.0};
```
```
//简化格式
数据类型[]数组名=[元素1，元素2，元素3，…}；
intll ages = {12,24,36};
```
### 注意
- “数据类型[]数组名”也可写成“数据类型 数组名[]”。
- 什么类型的数组只能存放什么类型的数据。
- 引用数据类型，存储的数组在内存中的地址信息。
## 数组的访问
- `数组名[索引]`
```
//取值
System.out.println(arr[e]);// 12
//赋值
arr[2] = 100;
System.out.println(arr[2]);// 100
```
- 如果访问数组时，使用的索引超过了数组最大索引会出什么问题？
    执行程序时会出bug，出现一个索引越界的异常提示。
#### 数组的长度属性：length
```
//获取数组的长度（就是数组元素的个数）
System.out.println(arr.length);// 3
```
- 数组的最大索引是多少？
    `数组名。length -1//前提：元素个数大于0`
### 数组的遍历
- 遍历：就是一个一个数据的访问。
- 为什么要遍历数组？
    求和 元素搜索 找最大最小值
- 2.如何遍历数组？
```
int[] ages = {20, 30,40, 50};
for (int i=0; i < ages.length; i++){
  System.out.println(ages[i]);
}
```
## 动态初始化数组
- 定义数组时先不存入具体的元素值，只确定数组存储的数据类型和数组的长度
- 数组的动态初始化格式：
```
数据类型[] 数组名=new 数据类型[长度];
int[] arr = new int[3];
```
```
// 后赋值
arr[e] = 10;
System.out.println(arr[e]);//10
```
- 温馨提示
    静态初始化和动态初始化数组的写法是独立的，不可以混用。
    - 如：
        `intll arr = new int[3]{30, 40,50};`
### 动态初始化数组元素默认值规则：
#### 基本类型
- byte, short, char, int. long
    默认值：0
- float. double
    默认值：0.0
- boolean
    默认值：false
#### 引用类型
- 类、接口、数组、==String==
    默认值：null
## 总结
1. 动态初始化数组的写法是什么样的？有什么特点?
```
数据类型[] 数组名=new 数据类型[长度];
int[] ages = new int[4];
```
2. 动态初始化数组后元素的默认值是什么样的？
    - byte、short、int、char、long类型数组的元素默认值都是0
    - float、 double类型数组元素的默认值都是0.0
    - boolean类型数组的元素默认值是false、String类型数组的元素的默认值是null
3. 两种数组定义的方法各自适合什么业务场景？
    - 动态初始化：适合开始不确定具体元素值，只知道元素个数的业务场景。
    - 静态初始化：适合一开始就知道要存入哪些元素值的业务场景。
# 03_数组在计算机中的执行原理
1. 运行一个Java程序，主要看JVM中包含的哪几部分内存区域？
    - 方法区
    - 栈内存
    - 堆内存
2. 简单说说`inta=20；int[] arr=new int[3]`这两行代码的执行原理？
    - a是变量，直接放在栈中，a变量中存储的数据就是20这个值。
    - `new int[3]`是创建一个数组对象，会在堆内存中开辟区域存储3个整数。
    - arr是变量，在栈中，arr中存储的是数组对象在堆内存中的地址值。
## 多个变量指向同一个数组
1. 使用数组时常见的一个问题
    - 如果某个数组变量存储的地址是null，那么该变量将不再指向任何数组对象
2. 多个数组变量，指向同一个数组对象的原因是什么？需要注意什么?
    - 多个数组变量中存储的是同一个数组对象的地址。
    - 多个变量修改的都是同一个数组对象中的数据。
3. 如果某个数组变量中存储的null，代表什么意思？需要注意什么？
    - 代表这个数组变量没有指向数组对象。
    - 可以输出这个变量，但是不能用这个数组变量去访问数据或者访问数组长度，
    - 会报空指针异常：NullPointerException。
