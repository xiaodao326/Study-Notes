# 01_日期对象
- 日期对象：用来表示时间的对象
- 作用：可以得到当前系统时间
## 实例化
- 在代码中发现了new关键字时，一般将这个操作称为===实例化===
- 创建一个时间对象并获取时间
例：
- 获得当前时间
```
const date
new Date()
```
- 获得指定时间
```
const date = new Date('2008-8-8')
console.log(date)
```
## 日期对象方法
- 使用场景：
    因为日期对象返回的数据我们不能直接使用，所以需要转换为实际开发中常用的格式
### getFullYear()
- 获得年份
- 获取四位年份
### getMonth()
- 获得月份
- 取值为0～11
### getDate()
- 获取月份中的每一天
- 不同月份取值也不相同
### getDay()
- 获取星期
- 取值为0～6
### getHours()
- 获取小时
- 取值为0～23
### getMinutes()
- 获取分钟
- 取值为0～59
### getSeconds()
- 获取秒
- 取值为0～59
## 时间戳
- 使用场景：
    如果计算倒计时效果，前面方法无法直接计算，需要借助于时间戳完成
- 什么是时间戳:
    是指1970年01月01日00时00分00秒起至现在的毫秒数，它是一种特殊的计量时间的方式
- 算法：
    - 将来的时间戳-现在的时间戳=剩余时间毫秒数
    - 剩余时间毫秒数转换为剩余时间的年月日时分秒就是倒计时时间
    - 比如 将来时间戳 2000ms -现在时间戳1000ms = 1000ms
    - 1000ms转换为就是0小时0分1秒
### 三种方式获取时间戳
1. 使用getTime()方法
```
const date =
new Date()console.log(date.getTime())
```
2. 简写+new Date()
    - 无需实例化
```
console.log(+new Date())
```
3. 使用Date.now()
    - 无需实例化
    - 但是只能得到当前的时间戳，而前面两种可以返回指定时间的时间戳
```
console.log(Date.now())
```

### 总结
1. 实例化日期对象怎么写？
    new Date()
2. 日期对象方法里面月份和星期有什么注意的？
    月份是0~11，星期是Q~6
3. 获取时间戳有哪三种方式？重点记住那个？
    - date.getTime()
    - +new Date()
    - Date.now()
    - 重点记住+new Date(）因为可以返回当前时间戳或者指定的时间戳
# 02_节点操作
## DOM节点
- 概念：
    DOM树里每一个内容都称之为节点
- 节点类型
    - 元素节点
        所有的标签 比如 body、div
        html是根节点
- 属性节点
    所有的属性 比如href
- 文本节点
    所有的文本
- 其他
### 总结
1. 什么是DOM节点?
    DOM树里每一个内容都称之为节点
2. DOM节点的分类？
- 元素节点 比如div标签
- 属性节点 比如class属性
- 文本节点 比如标签里面的文字
3. 我们重点记住那个节点?
    元素节点
    可以更好的让我们理清标签元素之间的关系
## 查询节点
### 父节点查找
- parentNode 属性
- 返回最近一级的父节点 找不到返回为null
- 语法：
    `子元素.parentNode`
### 子节点查找
- childNodes
    获得所有子节点、包括文本节点（空格、换行）、注释节点等
- ===children 属性（重点）===
    - 仅获得所有元素节点
    - 返回的还是一个伪数组
- 语法：
    `父元素.children`
### 兄弟关系查找
1. 下一个兄弟节点
    nextElementSibling 属性
2. 上一个兄弟节点
    previousElementSibling 属性
### 总结
1. 查找父节点用那个属性？
    parentNode
2. 查找所有子节点用那个属性？
    children
3. 查找兄弟节点用那个属性？
    nextElementSibling
    previousElementSibling
## 增加节点
### 创建节点
- 即创造出一个新的网页元素，再添加到网页内，一般先创建节点，然后插入节点
- 创建元素节点方法：
```
// 创造一个新的元素节点
document.createElement('标签名')
```
### 追加节点
- 要想在界面看到，还得插入到某个父元素中
- 插入到父元素的最后一个子元素:
```
// 插入到这个父元素的最后
父元素.appendChild（要插入的元素）
```

- 插入到父元素中某个子元素的前面:
```
// 插入到某个子元素的前面
父元素.insertBefore(要插入的元素，在哪个元素前面)
```
### 克隆节点
```
// 克隆一个已有的元素节点
元素.cloneNode（布尔值）
```
- cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值
    - 若为true，则代表克隆时会包含后代节点一起克隆
    - 若为false，则代表克隆时不包含后代节点
    - 默认为false
## 删除节点
- 若一个节点在页面中已不需要时，可以删除它
- 在JavaScript 原生DOM操作中，要删除元素必须通过父元素删除
- 语法:
`父元素.removeChild（要删除的元素`
- 注：
    如不存在父子关系则删除不成功
- 删除节点和隐藏节点（display:none）有区别的： 
    隐藏节点还是存在的，但是删除，则从html中删除节点
# 03_M端事件
- 移动端也有自己独特的地方。比如触屏事件touch（也称触摸事件），Android和10S都有。
- 触屏事件 touch（也称触摸事件），Android和10S都有。
- touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。
- 常见的触屏事件如下:
    - touchstart
        手指触摸到一个DOM元素时触发
    - touchmove
        手指在一个DOM元素上滑动时触发
    - touchend
        手指从一个DOM元素上移开时触发
# 04_Windows对象
## BOM(浏览器对象模型)

- BOM(Browser Object Model）是浏览器对象模型
- window对象是一个全局对象，也可以说是JavaScript中的顶级对象
- 像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的。
- 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法
- window对象下的属性和方法调用的时候可以省略window
## 定时器-延时函数
- JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout
- 语法：
`setTimeout(回调函数，等待的毫秒数）`
- setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行，平时省略window
- 清除延时函数：
```
let timer = setTimeout(回调函数，等待的毫秒数)
clearTimeout(timer)
```
- 注意点：
    - 延时器需要等待，所以后面的代码先执行
    - 每一次调用延时器都会产生一个新的延时器
### 两种定时器对比：执行的次数
- 延时函数：执行一次
- 间歇函数：每隔一段时间就执行一次，除非手动清除
## JS 执行机制
- JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。
- 这是因为Javascript 这门脚本语言诞生的使命所致——JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。
- 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。
- 为了解决这个问题，利用多核CPU的计算能力，HTML5提出 WebWorker 标准，允许JavaScript 脚本创建多个线程。于是，JS中出现了同步和异步。
- 同步
    前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。
- 异步
    你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。
- ===他们的本质区别： 这条流水线上各个流程的执行顺序不同。===
1. 先执行执行栈中的同步任务。
2. 异步任务放入任务队列中。
3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。
#### 同步任务
- 同步任务都在主线程上执行，形成一个执行栈。
#### 异步任务
- JS的异步是通过回调函数实现的。
- 一般而言，异步任务有以下三种类型：
1. 普通事件，如click、resize等
2. 资源加载，如load、error等
3. 定时器，包括setInterval、setTimeout等
- 异步任务相关添加到任务队列中（任务队列也称为消息队列）。
## location对象
- location的数据类型是对象，它拆分并保存了URL地址的各个组成部分
- 常用属性和方法：
     href属性获取完整的URL地址，对其赋值时用于地址的跳转
```
// 可以得到当前文件URL地址console.log(location.href)// 可以通过js方式跳转到目标地址
location.href = 'http://www.itcast.cn
```
- location的数据类型是对象，它拆分并保存了URL地址的各个组成部分
- 常用属性和方法：
    search 属性获取地址中携带的参数，符号？后面部分
    `console.log(location.search)`
## navigator对象
- navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息
- 常用属性和方法：
    通过 userAgent 检测浏览器的版本及平台
```
//检测 userAgent（浏览器信息)
!(function 0{
const userAgent = navigator.userAgent
// 验证是否为Android或iPhone
const android = userAgent.match(/(Android);?[¥s￥/]+([￥d.]+)?/)
const iphone = userAgent.match(/(iPhone¥sOS)￥s([￥d_]+)/)
// 如果是AndroidsiPhone，则跳转至移动站点
if (android l iphone)I
location.href = 'http://m.itcast.cn'}
})()
```
## histroy对象
- history 的数据类型是对象，主要管理历史记录，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等
- 常用属性和方法：
    back()
        可以后退功能
    forward() 
        前进功能
    go（参数) 
        前进后退功能 参数如果是 1前进1个页面 如果是-1后退1个页面
- history 对象一般在实际开发中比较少用，但是会在一些OA办公系统中见到。
# 05_本地存储
## 本地存储介绍
- 以前我们页面写的数据一刷新页面就没有了，是不是?
- 随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。
1. 数据存储在用户浏览器中
2. 设置、读取方便、甚至页面刷新不丢失数据
3. 容量较大，sessionStorage和localStorage约 5M左右
- 常见的使用场景：
    https://todomvc.com/examples/vanilla-es6/ 页面刷新数据不丢失
## 本地存储分类-localStorage
- 存储数据：
    `localStorage.setltem(key, value)`
- 获取数据：
    `localStorage.getltem(key)`
- 作用：可以将数据永久存储在本地（用户的电脑)，除非手动删除，否则关闭页面也会存在
- 特性：
    可以多窗口（页面）共享（同一浏览器可以共享）
    以键值对的形式存储使用
## 本地存储分类-sessionStorage
- 特性：
    - 生命周期为关闭浏览器窗口
    - 在同一个窗口（页面）下数据可以共享
    - 以键值对的形式存储使用
    - 用法跟localStorage基本相同
## 总结
1. localStorage作用是什么？
    可以将数据永久存储在本地(用户的电脑)，除非手动删除，否则关闭页面也会存在
2. localStorage存储，获取，删除的语法是什么?
    存储：localStorage.setltem(key，value)
    获取：localStorage.getitem(key)
    删除：localStorage.removeltem(key)